#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const { execSync: _execSync } = require('child_process')
const crypto = require('crypto')

// Arquivo escolhido para port-manager ap√≥s download (ex: 'port-manager.cjs' ou 'port-manager.mjs')
let portManagerFilename = null

// Baixa a variante adequada de port-manager: prefere .cjs quando poss√≠vel, usa .mjs via import se o runtime for ESM
async function ensurePortManager() {
  // Detecta se estamos em um runtime CommonJS (require existe)
  const preferCjs = typeof require === 'function'
  const preferExt = preferCjs ? 'cjs' : 'mjs'
  const fallbackExt = 'cjs'

  const targetFile = `port-manager.${preferExt}`
  const targetPath = path.join(__dirname, targetFile)
  const repoUrl = `https://raw.githubusercontent.com/anpdgovbr/docker-infra-pg/main/${targetFile}`

  // Se j√° existe, apenas marcar e retornar
  if (fs.existsSync(targetPath)) {
    portManagerFilename = targetFile
    return true
  }

  console.log(`üîÑ Baixando ${targetFile}...`)

  const https = require('https')

  // tenta baixar a variante preferida; se n√£o encontrar (404), tenta fallback (.cjs)
  try {
    const data = await new Promise((resolve, reject) => {
      https
        .get(repoUrl, res => {
          if (res.statusCode !== 200) {
            reject(new Error(`HTTP ${res.statusCode}`))
            return
          }
          let body = ''
          res.on('data', chunk => (body += chunk))
          res.on('end', () => resolve(body))
          res.on('error', reject)
        })
        .on('error', reject)
    })

    fs.writeFileSync(targetPath, data)
    console.log(`‚úÖ ${targetFile} baixado com sucesso!`)
    portManagerFilename = targetFile
    return true
  } catch (err) {
    // se a prefer√™ncia falhou, tentar baixar a variante .cjs como fallback
    if (preferExt !== fallbackExt) {
      const fallbackFile = `port-manager.${fallbackExt}`
      const fallbackPath = path.join(__dirname, fallbackFile)
      const fallbackUrl = `https://raw.githubusercontent.com/anpdgovbr/docker-infra-pg/main/${fallbackFile}`
      try {
        console.log(`‚ÑπÔ∏è  N√£o foi poss√≠vel baixar ${targetFile} (tentando ${fallbackFile})`)
        const data2 = await new Promise((resolve, reject) => {
          https
            .get(fallbackUrl, res => {
              if (res.statusCode !== 200) {
                reject(new Error(`HTTP ${res.statusCode}`))
                return
              }
              let body = ''
              res.on('data', chunk => (body += chunk))
              res.on('end', () => resolve(body))
              res.on('error', reject)
            })
            .on('error', reject)
        })

        fs.writeFileSync(fallbackPath, data2)
        console.log(`‚úÖ ${fallbackFile} baixado com sucesso! (fallback)`)
        portManagerFilename = fallbackFile
        return true
      } catch (err2) {
        console.warn(
          '‚ö†Ô∏è  N√£o foi poss√≠vel baixar port-manager (nem variante preferida nem fallback), usando detec√ß√£o b√°sica de porta'
        )
        if (err2?.message) console.warn('Detalhes do erro:', err2.message)
        return false
      }
    }

    console.warn('‚ö†Ô∏è  N√£o foi poss√≠vel baixar port-manager, usando detec√ß√£o b√°sica de porta')
    if (err?.message) console.warn('Detalhes do erro:', err.message)
    return false
  }
}

// Fun√ß√£o para detectar porta inteligente (fallback local se port-manager n√£o estiver dispon√≠vel)
async function getSmartPort() {
  const hasPortManager = await ensurePortManager()

  if (hasPortManager) {
    try {
      // carrega dinamicamente a variante baixada
      if (
        portManagerFilename &&
        portManagerFilename.endsWith('.cjs') &&
        typeof require === 'function'
      ) {
        const portManager = require(`./${portManagerFilename}`)
        return await portManager.getSmartPort()
      }

      if (portManagerFilename && portManagerFilename.endsWith('.mjs')) {
        // em runtime ESM: importar dinamicamente; se o m√≥dulo for CommonJS fallback, usamos createRequire
        try {
          const portManager = await import(`./${portManagerFilename}`)
          // suportar export padr√£o ou named
          const pm = portManager.default || portManager
          return await pm.getSmartPort()
        } catch (importErr) {
          // tentar fallback para require via createRequire (compat√≠vel com CommonJS)
          try {
            const { createRequire } = require('module')
            const requireFn = createRequire(__filename)
            const portManager = requireFn(`./port-manager.cjs`)
            return await portManager.getSmartPort()
          } catch (creqErr) {
            console.warn(
              '‚ö†Ô∏è  Erro ao importar port-manager.mjs; usando detec√ß√£o b√°sica:',
              importErr.message
            )
          }
        }
      }

      // fallback geral: tentar carregar .cjs com require se estiver dispon√≠vel
      if (
        typeof require === 'function' &&
        fs.existsSync(path.join(__dirname, 'port-manager.cjs'))
      ) {
        const portManager = require('./port-manager.cjs')
        return await portManager.getSmartPort()
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è  Erro ao usar port-manager, usando detec√ß√£o b√°sica:', error.message)
    }
  }

  // Fallback: detec√ß√£o b√°sica de porta
  const net = require('net')

  const isPortAvailable = port => {
    return new Promise(resolve => {
      const server = net.createServer()

      function onListen() {
        server.once('close', onClose)
        server.close()
      }

      function onClose() {
        resolve(true)
      }

      function onError() {
        resolve(false)
      }

      server.listen(port, onListen)
      server.on('error', onError)
    })
  }

  // Testa portas comuns PostgreSQL
  for (let port = 5432; port <= 5450; port++) {
    if (await isPortAvailable(port)) {
      console.log(`üéØ Porta ${port} dispon√≠vel (detec√ß√£o b√°sica)`)
      return port
    }
  }

  console.warn('‚ö†Ô∏è  Nenhuma porta padr√£o dispon√≠vel, usando 5432')
  return 5432
}

// Fun√ß√£o para detectar configura√ß√µes do projeto
function detectProjectConfig() {
  const projectRoot = process.cwd()

  // Ler package.json
  const packageJsonPath = path.join(projectRoot, 'package.json')
  if (!fs.existsSync(packageJsonPath)) {
    console.error(
      '‚ùå package.json n√£o encontrado. Este comando deve ser executado na raiz do projeto.'
    )
    process.exit(1)
  }

  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'))
  const projectName = packageJson.name || path.basename(projectRoot)

  // Ler .env se existir
  const envPath = path.join(projectRoot, '.env')
  let envConfig = {}

  if (fs.existsSync(envPath)) {
    const envContent = fs.readFileSync(envPath, 'utf8')
    envContent.split('\n').forEach(line => {
      const [key, ...valueParts] = line.split('=')
      if (key && valueParts.length > 0) {
        envConfig[key.trim()] = valueParts
          .join('=')
          .trim()
          .replace(/^((["'])|(["'])$)/g, '')
      }
    })
  }

  return { projectName, envConfig, packageJson }
}

// Fun√ß√£o para gerar senha segura
function generateSecurePassword() {
  return crypto.randomBytes(16).toString('hex')
}

// Fun√ß√£o para extrair dados da DATABASE_URL
function parseDatabaseUrl(databaseUrl) {
  if (!databaseUrl) return {}

  try {
    const url = new URL(databaseUrl)
    return {
      username: url.username,
      password: url.password,
      host: url.hostname,
      port: url.port || '5432',
      database: url.pathname.slice(1).split('?')[0]
    }
  } catch {
    return {}
  }
}

// Fun√ß√£o para criar docker-compose.yml
function createDockerCompose(config) {
  const { projectName, port, dbName, username, password } = config

  // Fun√ß√£o para sanitizar nomes Docker (n√£o pode come√ßar com underscore, h√≠fen ou ponto)
  const sanitizeName = name => {
    return name
      .replace(/[^a-zA-Z0-9]/g, '_') // Substituir caracteres especiais por underscore
      .replace(/^[^a-zA-Z0-9]+/, '') // Remover underscores, h√≠fens do in√≠cio
      .replace(/^$/, 'project') // Se vazio, usar 'project'
      .toLowerCase() // Docker prefere lowercase
  }

  // Nome do container e network √∫nicos por projeto
  const safeName = sanitizeName(projectName)
  const containerName = `${safeName}_postgres`
  const networkName = `${safeName}_network`
  const volumeName = `${safeName}_postgres_data`

  const dockerComposeContent = `name: ${safeName}-stack

services:
  postgres:
    image: postgres:15
    container_name: ${containerName}
    restart: unless-stopped
    environment:
      POSTGRES_USER: ${username}
      POSTGRES_PASSWORD: ${password}
      POSTGRES_DB: ${dbName}
      PGDATA: /var/lib/postgresql/data/pgdata
    ports:
      - "${port}:5432"
    volumes:
      - ${volumeName}:/var/lib/postgresql/data
      - ./init:/docker-entrypoint-initdb.d
    networks:
      - ${networkName}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${username} -d ${dbName}"]
      interval: 30s
      timeout: 10s
      retries: 5

volumes:
  ${volumeName}:
    name: ${volumeName}

networks:
  ${networkName}:
    name: ${networkName}
    driver: bridge
`

  return dockerComposeContent
}

// Fun√ß√£o para criar script de inicializa√ß√£o
function createInitScript(config) {
  const { dbName, username } = config

  return `#!/bin/bash
set -e

echo "üîÑ Configurando banco de dados ${dbName}..."

# Criar usu√°rio se n√£o existir
psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
    DO
    \\$\\$
    BEGIN
        IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = '${username}') THEN
            CREATE USER ${username} WITH ENCRYPTED PASSWORD '${config.password}';
        END IF;
    END
    \\$\\$;
    
    -- Garantir que o usu√°rio tem permiss√µes no banco
    GRANT ALL PRIVILEGES ON DATABASE ${dbName} TO ${username};
    
    -- Se estivermos no PostgreSQL 15+, garantir permiss√µes no schema public
    \\c ${dbName}
    GRANT ALL ON SCHEMA public TO ${username};
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO ${username};
    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO ${username};
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO ${username};
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO ${username};
EOSQL

echo "‚úÖ Banco de dados ${dbName} configurado com sucesso!"
`
}

// Fun√ß√£o para atualizar .env
function updateEnvFile(config) {
  const { port, dbName, username, password } = config
  const projectRoot = process.cwd()
  const envPath = path.join(projectRoot, '.env')

  const databaseUrl = `postgresql://${username}:${password}@localhost:${port}/${dbName}?schema=public`

  let envContent = ''
  let existingEnv = {}

  // Ler .env existente
  if (fs.existsSync(envPath)) {
    const currentContent = fs.readFileSync(envPath, 'utf8')
    envContent = currentContent

    // Parse existing env
    currentContent.split('\n').forEach(line => {
      const [key, ...valueParts] = line.split('=')
      if (key && valueParts.length > 0) {
        existingEnv[key.trim()] = valueParts.join('=').trim()
      }
    })
  }

  // Atualizar ou adicionar vari√°veis
  const envVars = {
    POSTGRES_DB: dbName,
    POSTGRES_USER: username,
    POSTGRES_PASSWORD: password,
    DATABASE_URL: `"${databaseUrl}"`
  }

  Object.entries(envVars).forEach(([key, value]) => {
    const regex = new RegExp(`^${key}=.*$`, 'm')
    if (regex.exec(envContent)) {
      envContent = envContent.replace(regex, `${key}=${value}`)
    } else {
      envContent += `${envContent && !envContent.endsWith('\n') ? '\n' : ''}${key}=${value}\n`
    }
  })

  fs.writeFileSync(envPath, envContent)

  return databaseUrl
}

// Fun√ß√£o principal
async function main() {
  console.log('üöÄ Configurando infraestrutura PostgreSQL com detec√ß√£o inteligente de porta...\n')

  try {
    // Detectar configura√ß√£o do projeto
    const { projectName: _projectName, envConfig } = detectProjectConfig()
    const projectName = _projectName
    console.log(`üì¶ Projeto detectado: ${projectName}`)

    // Detectar porta inteligente
    console.log('üîç Detectando porta dispon√≠vel...')
    const port = await getSmartPort()

    // Extrair dados existentes da DATABASE_URL
    const existingDb = parseDatabaseUrl(envConfig.DATABASE_URL)

    // Configura√ß√£o do banco
    const dbConfig = {
      projectName,
      port,
      dbName:
        existingDb.database ||
        envConfig.POSTGRES_DB ||
        `${projectName.replace(/[^a-zA-Z0-9]/g, '_')}_dev`,
      username: existingDb.username || envConfig.POSTGRES_USER || 'dev_user',
      password: existingDb.password || envConfig.POSTGRES_PASSWORD || generateSecurePassword()
    }

    console.log('üìã Configura√ß√£o final:')
    console.log(`   üéØ Porta: ${dbConfig.port}`)
    console.log(`   üóÑÔ∏è  Banco: ${dbConfig.dbName}`)
    console.log(`   üë§ Usu√°rio: ${dbConfig.username}`)
    console.log(`   üîê Senha: ${'*'.repeat(dbConfig.password.length)}`)

    // Criar pasta infra-db se n√£o existir
    const infraPath = path.join(process.cwd(), 'infra-db')
    if (!fs.existsSync(infraPath)) {
      fs.mkdirSync(infraPath, { recursive: true })
    }

    // Criar pasta init se n√£o existir
    const initPath = path.join(infraPath, 'init')
    if (!fs.existsSync(initPath)) {
      fs.mkdirSync(initPath, { recursive: true })
    }

    // Criar arquivos
    console.log('\nüìù Criando arquivos...')

    // docker-compose.yml
    const dockerComposePath = path.join(infraPath, 'docker-compose.yml')
    fs.writeFileSync(dockerComposePath, createDockerCompose(dbConfig))
    console.log('‚úÖ docker-compose.yml criado')

    // Script de inicializa√ß√£o
    const initScriptPath = path.join(initPath, '01-create-app-database.sh')
    fs.writeFileSync(initScriptPath, createInitScript(dbConfig))
    console.log('‚úÖ Script de inicializa√ß√£o criado')

    // Atualizar .env
    const databaseUrl = updateEnvFile(dbConfig)
    console.log('‚úÖ .env atualizado')

    console.log('\nüéâ Infraestrutura configurada com sucesso!')

    // Op√ß√£o recomendada para a maioria dos usu√°rios (usa os scripts do package.json)
    console.log('\nÔøΩ Recomendado (mais simples):')
    console.log('   1. npm run infra:up')
    console.log('   2. Aguarde ~30s para inicializa√ß√£o completa')

    // Alternativa manual para usu√°rios avan√ßados
    console.log('\nüìã Alternativa manual:')
    console.log('   1. cd infra-db')
    console.log('   2. docker-compose up -d')
    console.log('   3. Aguarde ~30s para inicializa√ß√£o completa')
    console.log(`   4. Teste a conex√£o: psql "${databaseUrl}"`)
    console.log('   5. Execute suas migrations/seeds')

    console.log('\nüîó DATABASE_URL configurada:')
    console.log(`   ${databaseUrl}`)
  } catch (error) {
    console.error('‚ùå Erro durante a configura√ß√£o:', error.message)
    process.exit(1)
  }
}

// Executar se chamado diretamente
if (require.main === module) {
  main()
}

module.exports = {
  getSmartPort,
  detectProjectConfig,
  createDockerCompose,
  updateEnvFile
}
